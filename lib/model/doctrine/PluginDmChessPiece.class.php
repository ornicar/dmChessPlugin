<?php

/**
 * PluginDmChessPiece
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 6820 2009-11-30 17:27:49Z jwage $
 */
abstract class PluginDmChessPiece extends BaseDmChessPiece
{
  public function getTargetKeys($protectKing = true)
  {
    return $this->getBoard()->squaresToKeys($this->getTargetSquares($protectKing));
  }

  public function getTargetSquares($protectKing = true)
  {
    $targets = $this->getBoard()->cleanSquares($this->getBasicTargetSquares());
    
    if ($protectKing)
    {
      $targets = $this->protectKingFilter($targets);
    }
    
    return $targets;
  }

  protected function getBasicTargetSquares()
  {
    throw new dmException('I am an abstract method');
  }
  
  protected function getTargetsByProjection($x, $y)
  {
    $squares = array();
    $continue = true;
    
    $square = $this->getSquare();

    while($continue)
    {
      if ($square = $square->getSquareByRelativePos($x, $y))
      {
        if ($otherPiece = $square->getPiece())
        {
          if (!$otherPiece->get('Player')->is($this->get('Player')))
          {
            $squares[] = $square;
          }
          
          $continue = false;
        }
        else
        {
          $squares[] = $square;
        }
      }
      else
      {
        $continue = false;
      }
    }
    
    return $squares;
  }
  
  // prevent a piece to eat a friend
  protected function cannibalismFilter(array $targets)
  {
    foreach($targets as $it => $target)
    {
      if ($target && ($piece = $target->getPiece()) && ($piece->get('Player')->is($this->get('Player'))))
      {
        unset($targets[$it]);
      }
    }
    
    return $targets;
  }
  
  // prevent leaving the king without protection
  protected function protectKingFilter(array $targets)
  {
    if(empty($targets))
    {
      return $targets;
    }
    
    $king = $this->get('Player')->getKing();
    $kingSquareKey = $king->getSquareKey();

    // create virtual objects
    $_game        = $this->getGame()->getCopy();
    $_game->getBoard()->clearCache();
    $_thisSquare  = $_game->getBoard()->getSquareByKey($this->getSquareKey());
    $_this        = $_thisSquare->getPiece();
    $_player      = $_this->get('Player');
    $_opponent    = $_player->getOpponent();

    // if we are moving the king, or if king is attacked, verify every opponent pieces
    if ($_this->isType('king') || $king->isAttacked())
    {
      $_opponentPieces = $this->getPieceFilter()->filterAlive($_opponent->get('Pieces'));
    }
    // otherwise only verify projection pieces: bishop, rooks and queens
    else
    {
      $_opponentPieces = $this->getPieceFilter()->filterAlive($this->getPieceFilter()->filterProjection($_opponent->get('Pieces')));
    }

    foreach($targets as $it => $square)
    {
      $_square = $_game->getBoard()->getSquareByKey($square->getKey());

      // kings move to its target
      if ($_this->isType('king'))
      {
        $kingSquareKey = $square->getKey();
      }

      // killed opponent piece
      if ($_killedPiece = $_square->getPiece())
      {
        $_killedPiece->kill(false);
      }

      $_this->set('x', $_square->getX());
      $_this->set('y', $_square->getY());
      
      $_game->getBoard()->compile();

      foreach($_opponentPieces as $_opponentPiece)
      {
        if ($_opponentPiece->get('is_dead'))
        {
          continue;
        }
        
        // if our king gets attacked
        if (in_array($kingSquareKey, $_opponentPiece->getTargetKeys(false)))
        {
          // can't go here
          unset($targets[$it]);
          break;
        }
      }

      // if a virtual piece has been killed, bring it back to life
      if ($_killedPiece)
      {
        $_killedPiece->set('is_dead', 0);
        $_killedPiece->set('x', $_square->getX());
        $_killedPiece->set('y', $_square->getY());
      }
    }
    
    // restore position
    $_this->set('x', $this->get('x'));
    $_this->set('y', $this->get('y'));
    
    return $targets;
  }
  
  public function moveToPos($x, $y, $checkMoveIntegrity = true)
  {
    return $this->moveToSquare($this->Board->getSquarebyPos($x, $y), $checkMoveIntegrity);
  }
  
  public function moveToSquareKey($squareKey, $checkMoveIntegrity = true)
  {
    return $this->moveToSquare($this->Board->getSquarebyKey($squareKey), $checkMoveIntegrity);
  }
  
  public function moveToSquare(dmChessSquare $square, $checkMoveIntegrity = true)
  {
    return $this->get('Player')->movePieceToSquare($this, $square, $checkMoveIntegrity = true);
  }
  
  public function kill($andSave = true)
  {
    $this->set('is_dead', $this->getGame()->get('turns'));
    $this->set('x', null);
    $this->set('y', null);
    
    if ($andSave)
    {
      $this->save();
    }
  }
  
  public function canMoveToSquare(dmChessSquare $square)
  {
    return in_array($square->getKey(), $this->getTargetKeys());
  }
  
  public function getSquare()
  {
    return $this->getBoard()->getSquareByKey($this->getSquareKey());
  }
  
  public function getGame()
  {
    return $this->get('Player')->get('Game');
  }
  
  public function getBoard()
  {
    return $this->getGame()->getBoard();
  }
  
  public function getPieceFilter()
  {
    return $this->get('Player')->getTable()->getPieceFilter();
  }
  
  public function getSquareKey()
  {
    return 's'.$this->get('x').$this->get('y');
  }
  
  public function toDebug()
  {
    $pos = ($square = $this->getSquare()) ? $square->getHumanPos() : 'no-pos';
    
    return $this->id.': '.$this->type.' '.$this->color.' in '.$pos;
  }

  public function __toString()
  {
    return $this->toDebug();
  }
  
  public function getColor()
  {
    return $this->get('Player')->get('color');
  }
  
  public function hasMoved()
  {
    return $this->get('first_move') != -1;
  }
  
  public function isType($type)
  {
    return $this->get('type') === $type;
  }

  public function preMove(dmChessSquare $oldSquare, dmChessSquare $square)
  {
    
  }
  
  public function postMove(dmChessSquare $oldSquare, dmChessSquare $square)
  {
    
  }

  public function preInsert($event)
  {
    parent::preInsert($event);
    
    $this->set('type', strtolower(str_replace('DmChess', '', get_class($this))));
  }
}