<?php

/**
 * PluginDmChessPawn
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 6820 2009-11-30 17:27:49Z jwage $
 */
abstract class PluginDmChessPawn extends BaseDmChessPawn
{

  protected function getDirection()
  {
    return $this->get('Player')->isWhite() ? 1 : -1;
  }

  protected function getBasicTargetSquares()
  {
    $mySquare = $this->getSquare();
    $squares = array();

    // selon leur couleur, les pions montent ou descendent
    $direction = $this->getDirection();

    // un pion peut avancer d'une square
    $squares[] = $mySquare->getSquareByRelativePos(0, $direction);

    // s'il ne s'est pas encore déplacé, un pion peut avancer de deux squares
    if (!$this->hasMoved())
    {
      $squares[] = $mySquare->getSquareByRelativePos(0, $direction*2);
    }

    $squares = $this->getBoard()->cleanSquares($squares);

    // ne peut manger en avant
    foreach($squares as $it => $square)
    {
      if ($square->getPiece())
      {
        for($i=$it, $max = count($squares); $i<$max; $i++)
        {
          unset($squares[$i]);
        }
      }
    }

    //peut manger en diagonale
    foreach(array(-1, 1) as $dx)
    {
      if($square = $mySquare->getSquareByRelativePos($dx, $direction))
      {
        if ($piece = $square->getPiece())
        {
          if (!$piece->get('Player')->is($this->get('Player')))
          {
            $squares[] = $square;
          }
        }
      }
    }

    // en passant
    foreach(array(-1, 1) as $dx)
    {
      if (
      ($square = $mySquare->getSquareByRelativePos($dx, 0)) &&
      ($piece = $square->getPiece()) &&
      $piece->isType('pawn') &&
      !$piece->get('Player')->is($this->get('Player')) &&
      ($piece->get('first_move') == ($this->get('Player')->get('Game')->get('turns') -1)) &&
      ($specialSquare = $mySquare->getSquareByRelativePos($dx, $direction)) &&
      $specialSquare->isEmpty()
      )
      {
        $squares[] = $specialSquare;
      }
    }

    return $squares;
  }

  public function postMove(dmChessSquare $oldSquare, dmChessSquare $square)
  {
    // handle promotion
    $lastY = $this->get('Player')->isWhite() ? 8 : 1;
    
    if ($square->getY() == $lastY)
    {
      $type = 'queen';

      $this->get('Player')->get('Pieces')->set($this->get('Player')->get('Pieces')->search($this),
        $piece = dmDb::table('DmChess'.ucfirst($type))->create()
        ->set('x', $this->x)
        ->set('y', $this->y)
        ->set('type', $type)
      );
      
      $this->getEventDispatcher()->notify(new dmChessPawnPromotionEvent($this, 'dm.chess.pawn_promotion', array(
        'type'      => $type,
        'old_piece' => $this,
        'new_piece' => $piece,
        'square'    => $square
      )));
    }
    // en passant
    elseif (
    $square->getX() !== $oldSquare->getX() &&
    $square->isEmpty() &&
    ($passedSquare = $square->getSquareByRelativePos(0, -$this->getDirection())) &&
    ($piece = $passedSquare->getPiece()) &&
    !$piece->get('Player')->is($this->get('Player'))
    )
    {
      $this->getEventDispatcher()->notify(new dmChessPawnEnPassantEvent($this, 'dm.chess.pawn_en_passant', array(
        'killer'    => $this,
        'killed'    => $piece,
        'square'    => $passedSquare
      )));
      
      $piece->kill(true);
    }
  }

  public function preInsert($event)
  {
    parent::preInsert($event);
    
    $this->y = $this->Player->isWhite() ? 2 : 7;
  }
}